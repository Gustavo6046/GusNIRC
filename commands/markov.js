// Generated by CoffeeScript 1.12.6
var _mkgroups, data, err, fr, fs, h2p, irc, k, m, markov, mkglisten, mkgroups, ref, saveMarkov,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

if (ref = require.resolve('../lib/markov.js'), indexOf.call(Object.keys(require.cache), ref) >= 0) {
  delete require.cache[require.resolve('../lib/markov.js')];
}

markov = require('../lib/markov.js');

irc = require("../irc.js");

fs = require("fs");

fr = require('follow-redirects');

h2p = require('html2plaintext');

try {
  data = JSON.parse(fs.readFileSync("markov.json", {
    encoding: "utf-8"
  }));
  _mkgroups = data[0];
  mkgroups = {};
  for (k in _mkgroups) {
    m = _mkgroups[k];
    mkgroups[k] = markov(1).fromJSON(m);
  }
  mkglisten = data[1];
} catch (error) {
  err = error;
  console.log("Markov loading skipped:");
  console.log(err);
  mkgroups = {};
  mkglisten = {};
}

saveMarkov = function() {
  var mkgdata, v;
  mkgdata = {};
  for (k in mkgroups) {
    v = mkgroups[k];
    mkgdata[k] = v.getDB();
  }
  return fs.writeFileSync("markov.json", JSON.stringify([mkgdata, mkglisten]));
};

module.exports = [
  {
    name: "markov.mkgroup",
    matcher: new irc.PrefixedMatcher("markov mkgroup ([^ ]+)"),
    perform: function(msg, custom, conn) {
      mkgroups[custom[0]] = markov(1);
      if (mkglisten[msg.data.privmsg.channel] != null) {
        mkglisten[msg.data.privmsg.channel].push(custom[0]);
      } else {
        mkglisten[msg.data.privmsg.channel] = [custom[0]];
      }
      return msg.reply("Made Markov group " + custom[0] + " succesfully. Listening for it on " + msg.data.privmsg.channel + " by default...");
    }
  }, {
    name: "markov.train",
    matcher: new irc.MessageMatcher("((?!]=).+)"),
    perform: function(msg, custom, conn) {
      var i, len, ref1, ref2, results;
      if (ref1 = msg.data.privmsg.channel, indexOf.call(Object.keys(mkglisten), ref1) >= 0) {
        ref2 = mkglisten[msg.data.privmsg.channel];
        results = [];
        for (i = 0, len = ref2.length; i < len; i++) {
          m = ref2[i];
          if (mkgroups[m] != null) {
            mkgroups[m].seed(custom[0]);
          }
          results.push(saveMarkov());
        }
        return results;
      }
    }
  }, {
    name: "markov.flush",
    matcher: new irc.PrefixedMatcher("markov (?:flush|clear) ([^ ]+)"),
    perform: function(msg, custom, conn) {
      var ref1;
      if (ref1 = custom[0], indexOf.call(Object.keys(mkgroups), ref1) < 0) {
        return msg.reply("No such Markov group '" + custom[0] + "'!");
      } else {
        mkgroups[custom[0]] = markov(1);
        msg.reply("Markov group '" + custom[0] + "' flushed successfully.");
        return saveMarkov();
      }
    }
  }, {
    name: "markov.filetrain",
    matcher: new irc.PrefixedMatcher("markov fromfile ([^ ]+) (.+)"),
    perform: function(msg, custom, conn) {
      var f, files, i, len, mk, results;
      files = custom[1].split(" ");
      mk = mkgroups[custom[0]];
      if (mk == null) {
        msg.reply("No such Markov group '" + custom[0] + "'!");
      }
      results = [];
      for (i = 0, len = files.length; i < len; i++) {
        f = files[i];
        if (!fs.exists(f)) {
          results.push(msg.reply("No such file '" + f + "'!"));
        } else {
          mk.seed(fs.readFileSync(f));
          results.push(msg.reply("File trained to Markov successfully."));
        }
      }
      return results;
    }
  }, {
    name: "markov.webtrain",
    matcher: new irc.PrefixedMatcher("markov webp ([^ ]+) (.+)"),
    perform: function(msg, custom, conn) {
      var i, len, mk, prot, ref1, results, s, sites;
      sites = custom[1].split(" ");
      mk = mkgroups[custom[0]];
      msg.reply("Extracting Markov from webpages.");
      results = [];
      for (i = 0, len = sites.length; i < len; i++) {
        s = sites[i];
        if (s.startsWith("https://")) {
          prot = fr.https;
        } else {
          prot = fr.http;
          if (!s.startsWith("http://")) {
            m = s.match(/^(([a-z][a-z1-9\-\+\.]+\:\/\/)?)(.+)/i).slice(1);
            if ((m != null) && ((ref1 = m[0]) !== "http" && ref1 !== "")) {
              msg.reply("[ERR] [markov.webtrain] " + s + " - Invalid protocol: " + m[0] + " (expected 'http', 'https' or default 'http')");
              continue;
            }
            s = "http://" + m[2];
          }
        }
        results.push(prot.get(s, function(response) {
          if (response.statusCode !== 200) {
            msg.reply("[ERR] [markov.webtrain] " + s + " - Status " + response.statusCode);
            return;
          }
          data = "";
          response.on("data", function(chunk) {
            return data += '' + chunk;
          });
          return response.on("end", function() {
            var e, txt;
            msg.reply("[INFO] [markov.webtrain] " + s + " - Request successful.");
            try {
              txt = h2p(data);
              try {
                mk.seed(txt);
              } catch (error) {
                e = error;
                msg.reply("[ERR] [markov.webtrain] " + s + " - Error training Markov with text: " + e);
              }
              return msg.reply("[INFO] [markov.webtrain] " + s + " - Parsed succesfully.");
            } catch (error) {
              err = error;
              return msg.reply("[ERR] [markov.webtrain] " + s + " - Error parsing: " + err);
            }
          });
        }).on("error", function(e) {
          return msg.reply("[ERR] [markov.webtrain] " + s + " - " + e);
        }));
      }
      return results;
    }
  }, {
    name: "markov.get",
    matcher: new irc.PrefixedMatcher("markov get ([^ ]+) (.+)"),
    perform: function(msg, custom, conn) {
      var ref1;
      if (ref1 = custom[0], indexOf.call(Object.keys(mkgroups), ref1) < 0) {
        return msg.reply("No such Markov group yet!");
      } else {
        data = custom[1] + " " + (mkgroups[custom[0]].forward(custom[1], 80).join(" "));
        if (data === "") {
          return msg.reply("[Key not found.]");
        } else {
          return msg.reply(data);
        }
      }
    }
  }, {
    name: "markov.list",
    matcher: new irc.PrefixedMatcher("markov list$"),
    perform: function(msg, custom, conn) {
      console.dir(mkgroups);
      return msg.reply("Available Markov groups: " + (Object.keys(mkgroups).join(", ")));
    }
  }, {
    name: "markov.listen",
    matcher: new irc.PrefixedMatcher("markov listen ([^ ]+)"),
    perform: function(msg, custom, conn) {
      var ref1;
      if (ref1 = custom[0], indexOf.call(Object.keys(mkgroups), ref1) < 0) {
        return msg.reply("No such Markov group " + custom[0] + " to listen for here!");
      } else {
        if (mkglisten[msg.data.privmsg.channel] != null) {
          mkglisten[msg.data.privmsg.channel].push(custom[0]);
        } else {
          mkglisten[msg.data.privmsg.channel] = [custom[0]];
        }
        return msg.reply("Now listening on " + msg.data.privmsg.channel + " for Markov group " + custom[0] + ".");
      }
    }
  }, {
    name: "markov.deafen",
    matcher: new irc.PrefixedMatcher("markov (deafen|ignore) ([^ ]+)"),
    perform: function(msg, custom, conn) {
      var ref1;
      if ((mkglisten[msg.data.privmsg.channel] != null) && (ref1 = custom[1], indexOf.call(mkglisten[msg.data.privmsg.channel], ref1) >= 0)) {
        mkglisten[msg.data.privmsg.channel] = mkglisten[msg.data.privmsg.channel].splice(mkglisten[msg.data.privmsg.channel].indexOf(custom[1]), 1);
        if (mkglisten[msg.data.privmsg.channel] === []) {
          delete mkglisten[msg.data.privmsg.channel];
        }
        saveMarkov();
        return msg.reply("Now not listening on " + msg.data.privmsg.channel + " for Markov group " + custom[1] + ".");
      } else {
        return msg.reply("No such Markov group listener for this channel!");
      }
    }
  }, {
    name: "markov.pick",
    matcher: new irc.PrefixedMatcher("markov (pick|random) ([^ ]+)"),
    perform: function(msg, custom, conn) {
      var inner;
      inner = function() {
        var key, ref1;
        if (ref1 = custom[1], indexOf.call(Object.keys(mkgroups), ref1) < 0) {
          return msg.reply("No such Markov group yet!");
        } else {
          key = mkgroups[custom[1]].pick();
          if (key == null) {
            return msg.reply("[Empty Markov chain...]");
          } else {
            data = mkgroups[custom[1]].forward(key, 80);
            if (data == null) {
              msg.reply("[Empty result text... try again?]");
            }
            data = data.join(" ");
            if (data.match(/^\s*$/)) {
              return inner();
            } else {
              return msg.reply(msg.data.privmsg.nickname + ": " + key + " " + data);
            }
          }
        }
      };
      return inner();
    }
  }
];
