// Generated by CoffeeScript 1.12.6
var EventEmitter, Hash, Lazy, clean, deck, markov;

EventEmitter = require('events').EventEmitter;

deck = require('deck');

Lazy = require('lazy');

Hash = require('hashish');

clean = function(s) {
  return s.toLowerCase().replace(/[^a-z\d]+/g, '_').replace(/^_/, '').replace(/_$/, '');
};

markov = function(order) {
  var db, self;
  if (!order) {
    order = 2;
  }
  db = {};
  self = {};
  self.fromJSON = function(j) {
    if (j instanceof String) {
      j = JSON.parse(j);
    }
    if (j instanceof Buffer) {
      j = JSON.parse(j.toString('utf-8'));
    }
    self.setDB(j);
    return self;
  };
  self.seed = function(seed, cb) {
    var i;
    var cnext, cword, i, link, links, n, next, node, prev, text, word, words;
    if (seed instanceof EventEmitter) {
      Lazy(seed).lines.forEach(self.seed);
      if (cb) {
        seed.on('error', cb);
        seed.on('end', cb);
      }
    } else {
      text = Buffer.isBuffer(seed) ? seed.toString() : seed;
      words = text.split(/\s+/);
      links = [];
      i = 0;
      while (i < words.length) {
        link = words.slice(i, i + order).join(' ');
        links.push(link);
        i += order;
      }
      if (links.length <= 1) {
        if (cb) {
          cb(null);
        }
        return;
      }
      i = 1;
      while (i < links.length) {
        word = links[i - 1];
        cword = clean(word);
        next = links[i];
        cnext = clean(next);
        node = Hash.has(db, cword) ? db[cword] : {
          count: 0,
          words: {},
          next: {},
          prev: {}
        };
        db[cword] = node;
        node.count++;
        node.words[word] = (Hash.has(node.words, word) ? node.words[word] : 0) + 1;
        node.next[cnext] = (Hash.has(node.next, cnext) ? node.next[cnext] : 0) + 1;
        if (i > 1) {
          prev = clean(links[i - 2]);
          node.prev[prev] = (Hash.has(node.prev, prev) ? node.prev[prev] : 0) + 1;
        } else {
          node.prev[''] = (node.prev[''] || 0) + 1;
        }
        i++;
      }
      if (!Hash.has(db, cnext)) {
        db[cnext] = {
          count: 1,
          words: {},
          next: {
            '': 0
          },
          prev: {}
        };
      }
      n = db[cnext];
      n.words[next] = (Hash.has(n.words, next) ? n.words[next] : 0) + 1;
      n.prev[cword] = (Hash.has(n.prev, cword) ? n.prev[cword] : 0) + 1;
      n.next[''] = (n.next[''] || 0) + 1;
      if (cb) {
        cb(null);
      }
    }
  };
  self.search = function(text) {
    var groups, i, start, word, words;
    words = text.split(/\s+/);
    start = null;
    groups = {};
    i = 0;
    while (i < words.length) {
      word = clean(words.slice(i, i + order).join(' '));
      if (Hash.has(db, word)) {
        groups[word] = db[word].count;
      }
      i += order;
    }
    return deck.pick(groups);
  };
  self.pick = function() {
    return deck.pick(Object.keys(db));
  };
  self.next = function(cur) {
    var next;
    if (!cur || !db[cur]) {
      return void 0;
    }
    next = deck.pick(db[cur].next);
    return next && {
      key: next,
      word: deck.pick(db[next].words) || void 0
    };
  };
  self.prev = function(cur) {
    var prev;
    if (!cur || !db[cur]) {
      return void 0;
    }
    prev = deck.pick(db[cur].prev);
    return prev && {
      key: prev,
      word: deck.pick(db[prev].words) || void 0
    };
  };
  self.forward = function(cur, limit) {
    var next, res;
    res = [];
    while (cur && !limit || res.length < limit) {
      next = self.next(cur);
      if (!next) {
        break;
      }
      cur = next.key;
      res.push(next.word);
    }
    return res;
  };
  self.backward = function(cur, limit) {
    var prev, res;
    res = [];
    while (cur && !limit || res.length < limit) {
      prev = self.prev(cur);
      if (!prev) {
        break;
      }
      cur = prev.key;
      res.unshift(prev.word);
    }
    return res;
  };
  self.fill = function(cur, limit) {
    var ncur, next, pcur, prev, res;
    res = [deck.pick(db[cur].words)];
    if (!res[0]) {
      return [];
    }
    if (limit && res.length >= limit) {
      return res;
    }
    pcur = cur;
    ncur = cur;
    while (pcur || ncur) {
      if (pcur) {
        prev = self.prev(pcur);
        pcur = null;
        if (prev) {
          pcur = prev.key;
          res.unshift(prev.word);
          if (limit && res.length >= limit) {
            break;
          }
        }
      }
      if (ncur) {
        next = self.next(ncur);
        ncur = null;
        if (next) {
          ncur = next.key;
          res.unshift(next.word);
          if (limit && res.length >= limit) {
            break;
          }
        }
      }
    }
    return res;
  };
  self.respond = function(text, limit) {
    var cur;
    cur = self.search(text) || self.pick();
    return self.fill(cur, limit);
  };
  self.word = function(cur) {
    return db[cur] && deck.pick(db[cur].words);
  };
  self.getDB = function() {
    return db;
  };
  self.setDB = function(newd) {
    return db = newd;
  };
  return self;
};

module.exports = markov;
